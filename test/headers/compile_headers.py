#! /usr/bin/env python

#
# Copyright (C) 2013 Canonical Ltd
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Authored by: Michi Henning <michi.henning@canonical.com>
#

#
# Little helper program to test that header files are stand-alone compilable (and therefore don't depend on
# other headers being included first).
#
# Usage: compile_headers.py directory compiler [compiler_flags]
#
# The directory specifies the location of the header files. All files in that directory ending in .h (but not
# in subdirectories) are tested.
#
# The compiler argument specifies the compiler to use (such as "gcc"), and the compiler_flags argument (which
# must be a single string argument, not a bunch of separate strings) specifies any additional flags, such
# as "-I -g". The flags need not include "-c".
#
# For each header file in the specified directory, the script create a corresponding .cpp that includes the
# header file. The .cpp file is created in the current directory (which isn't necessarily the same one as
# the directory the header files are in). The script runs the compiler on the generated .cpp file and, if the
# compiler returns non-zero exit status, it prints a message (on stdout) reporting the failure.
#
# The script does not stop if a file fails to compile. If all source files compile successfully, no output (other
# than the output from the compiler) is written, and the exit status is zero. If one or more files do not compile,
# or there are any other errors, such as not being able to open a file, exit status is non-zero.
#
# Messages about files that fail to compile are written to stdout. Message about other problems, such as non-existent
# files and the like, are written to stderr.
#
# The compiler's output goes to whatever stream the compiler writes to and is left alone.
#
# If a header file compiles without error, the corresponding source file is removed. Otherwise, the .cpp file is
# left behind.
#
# If a source file already exists, the script uses a simple test to avoid overwriting a legitimate source file
# by checking the start of the file for a magic cookie. This prevents clobbering an entire directory full of
# source files by accidentally running the script in the wrong place.
#

import argparse
import os
import subprocess
import sys
import re

progname = sys.argv[0]

#
# Write the supplied message to the specified stream, followed by a newline.
#
def error(stream, msg):
    print >> stream, progname + ": " + msg + "\n"

#
# Check that it is safe to overwrite the file by checking for the cookie at the start of the file. Return
# the file descriptor to the truncated file if it can be overwritten, -1 otherwise.
#
def check_overwrite(src, cookie):
    fd = -1
    try:
        fd = os.open(src, os.O_EXCL | os.O_RDWR)
        line1 = os.read(fd, len(cookie))
        if line1 != cookie:
            error(sys.stderr, "will not overwrite existing file \"" + src + "\"")
            os.close(fd);
            return -1
        os.lseek(fd, 0, os.SEEK_SET)
        os.ftruncate(fd, 0)
    except OSError as e:
        error(sys.stderr, e.strerror)
        if fd != -1:
            os.close(fd)
        raise
    return fd

#
# Create a source file in the current directory that includes the specified header. A simple sanity check
# is used to make it unlikely that we accidentally overwrite a source file not generated by this function.
# Returns the name of the created file, or throws if the file could not be created or overwritten.
#
def create_src_file(hdr, cookie):
    src = re.sub(r'(.+)\.h$', r'\1.cpp', hdr)
    try:
        fd = os.open(src, os.O_CREAT | os.O_EXCL | os.O_WRONLY)
    except OSError as e:
        if e.errno == os.errno.EEXIST:
            fd = check_overwrite(src, cookie)
        else:
            error(sys.stderr, e.strerror)
            raise

    if fd != -1:
        try:
            os.write(fd, cookie + "\n");
            os.write(fd, "#include <" + hdr + ">" + "\n");
        except OSError as e:
            error(sys.stderr, e.strerror)
            raise
        finally:
            os.close(fd)
    return src

#
# Compile the passed src file and check exit status from the compiler. Throw if the compile command fails itself fails,
# return 1 if the compile command worked but reported errors.
#
def run_compiler(src, compiler, copts):
    if args.verbose:
        print compiler + " -c " + copts + " " + src
    try:
        status = subprocess.call(compiler + " -c " + copts + " " + src, shell="true")
        if status != 0:
            error(sys.stdout, "cannot compile \"" + src + "\"")
            return 1
        else:
            os.unlink(src)
            obj = re.sub(r'(.+)\.cpp$', r'\1.o', src)
            os.unlink(obj)
            return 0
    except OSError as e:
        error(sys.stderr, e.strerror)
        raise

#
# For each of the supplied headers, create a source file in the current directory that includes the header
# and then try to compile the header. Returns normally if all files could be compiled successfully and
# throws, otherwise.
#
def test_files(hdrs, compiler, copts, cookie):
    errs = 0
    for h in hdrs:
        try:
            src = create_src_file(h, cookie)
            errs += run_compiler(src, compiler, copts)
        except OSError:
            errs += 1
            pass    # Error reported already
    if errs != 0:
        msg = str(errs) + " file"
        if errs != 1:
            msg += "s"
        msg += " failed to compile"
        error(sys.stderr, msg)
        sys.exit(1)

#
# Main program.
#

#
# Parse arguments.
#
parser = argparse.ArgumentParser(description = 'Test that all headers in the passed directory compile stand-alone.')
parser.add_argument('-v', '--verbose', action='store_true', help = 'Trace invocations of the compiler')
parser.add_argument('dir', nargs = 1, help = 'The directory to look for header files ending in ".h"')
parser.add_argument('compiler', nargs = 1, help = 'The compiler executable, such as "gcc"')
parser.add_argument('copts', nargs = '?', default="",
                    help = 'The compiler options (excluding -c), such as "-g -Wall -I." as a single string.')
args = parser.parse_args()
progname = parser.prog

cookie = "//\n// File generated by compile_headers.py. DO NOT EDIT: CONTENTS WILL BE OVERWRITTEN!\n//"

#
# Find all the .h files in specified directory and do the compilation for each one.
#
dir = args.dir[0]
try:
    files = os.listdir(dir)
except OSError as e:
    msg = "cannot open \"" + dir + "\": " + e.strerror
    error(sys.stderr, msg)
    sys.exit(1)
pat = re.compile(r'.+\.h$')
hdrs = [hdr for hdr in files if pat.match(hdr)]

try:
    test_files(hdrs, args.compiler[0], args.copts, cookie)
except OSError:
    sys.exit(1)    # Errors were written earlier

sys.exit    # All went well
